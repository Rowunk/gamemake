<!doctype html>
<meta charset="utf-8" />
<title>Textured Cube + Depth (WebGL2 only)</title>
<link rel="stylesheet" href="../../lib/style.css">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E">

<canvas id="canvas"></canvas>

<div class="panel">
  <b>Textured Cube + Mipmaps</b>
  路 <span class="small">Drag to orbit 路 Wheel to zoom</span>
  路 <span id="mode" class="small">WebGL2</span>
  路 Sampler
  <select id="samp">
    <option value="mipmapLinear" selected>mipmapLinear</option>
    <option value="linearClamp">linearClamp</option>
    <option value="nearestRepeat">nearestRepeat</option>
  </select>
</div>

<script type="module">
import {
  fitCanvasToDisplaySize,
  onResize,
  rafLoop,
  hasWebGL2,
  makeCheckerRGBA8
} from '../../lib/harness.js';

import { resizeWebGL2 } from '../../../src/gfx/resize.js';
import {
  webgl2UploadRGBA8Texture as uploadTextureRGBA8WebGL2
} from '../../../src/gfx/texture_upload.js';
import { perspective, makeOrbitController } from '../../../src/gfx/camera.js';
import { Mat4 } from '../../../src/core/math/mat4.js';
import { HandlePool } from '../../../src/runtime/handles.js';
import { Flags, makeTester, applyHeadless } from '../../lib/testkit.js';

// Headless harness setup
applyHeadless(Flags.headless);
const t = makeTester('3d/textured_cube');

const canvas = document.getElementById('canvas');
const modeEl = document.getElementById('mode');
const sampEl = document.getElementById('samp');

modeEl.textContent = 'WebGL2';

// ===== Orbit camera controls =====
const orbit = makeOrbitController({ distance: 4, yaw: 0.6, pitch: 0.6 });
let dragging = false, px = 0, py = 0;
canvas.addEventListener('pointerdown', e => { dragging = true; px = e.clientX; py = e.clientY; canvas.setPointerCapture(e.pointerId); });
canvas.addEventListener('pointerup',   e => { dragging = false; canvas.releasePointerCapture(e.pointerId); });
canvas.addEventListener('pointermove', e => {
  if (!dragging) return;
  const dx = e.clientX - px, dy = e.clientY - py;
  px = e.clientX; py = e.clientY;
  orbit.update(-dx * 0.005, -dy * 0.005, 0);
});
canvas.addEventListener('wheel', e => {
  orbit.update(0, 0, Math.sign(e.deltaY) * 0.1);
  e.preventDefault();
}, { passive: false });

// ===== Geometry: textured cube =====
function createTexturedCubeGeometry() {
  const positions = new Float32Array([
    -1, -1, -1,  1, -1, -1,  1,  1, -1,  -1,  1, -1,
    -1, -1,  1,  1, -1,  1,  1,  1,  1,  -1,  1,  1,
  ]);
  const uvs = new Float32Array([
    0, 0,  1, 0,  1, 1,  0, 1,
    1, 0,  0, 0,  0, 1,  1, 1,
  ]);
  const indices = new Uint16Array([
    4, 5, 6,  4, 6, 7,
    1, 0, 3,  1, 3, 2,
    5, 1, 2,  5, 2, 6,
    0, 4, 7,  0, 7, 3,
    3, 7, 6,  3, 6, 2,
    0, 1, 5,  0, 5, 4,
  ]);
  return { positions, uvs, indices };
}

// ===== GL utils =====
function compile(gl, type, src) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(sh) || 'shader compile failed');
  }
  return sh;
}
function link(gl, vs, fs) {
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(prog) || 'program link failed');
  }
  return prog;
}

// ===== Sampler presets =====
function applySamplerPreset(gl, texture, preset, hasMips) {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  switch (preset) {
    case 'mipmapLinear':
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, hasMips ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      break;
    case 'linearClamp':
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      break;
    case 'nearestRepeat':
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, hasMips ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      break;
    default:
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }
  gl.bindTexture(gl.TEXTURE_2D, null);
}

// ===== Main =====
async function startWebGL2() {
  if (!hasWebGL2(canvas)) {
    t.ok(false, 'WebGL2 unavailable');
    return;
  }
  const gl = canvas.getContext('webgl2', { antialias: false, depth: true });
  if (!gl) {
    t.ok(false, 'Failed to get WebGL2 context');
    return;
  }
  const handles = new HandlePool({ capacity: 256 });

  // FIXED: match function signature
  const checker = makeCheckerRGBA8(256, 256, 8);
  const { handle: texture, levelCount } =
    uploadTextureRGBA8WebGL2(gl, checker.data, checker.width, checker.height, { mipmapped: true });
  const hasMips = levelCount > 1;
  const textureHandle = handles.create(texture);

  applySamplerPreset(gl, texture, sampEl.value, hasMips);
  sampEl.addEventListener('change', () => {
    applySamplerPreset(gl, handles.get(textureHandle), sampEl.value, hasMips);
    t.ok(true, 'sampler changed');
  });

  const VS = `#version 300 es
    layout(location=0) in vec3 a_pos;
    layout(location=1) in vec2 a_uv;
    uniform mat4 u_mvp;
    out vec2 v_uv;
    void main() {
      v_uv = a_uv;
      gl_Position = u_mvp * vec4(a_pos, 1.0);
    }`;
  const FS = `#version 300 es
    precision mediump float;
    in vec2 v_uv;
    uniform sampler2D u_tex;
    out vec4 frag;
    void main() {
      frag = texture(u_tex, v_uv);
    }`;
  const prog = link(gl, compile(gl, gl.VERTEX_SHADER, VS), compile(gl, gl.FRAGMENT_SHADER, FS));
  gl.useProgram(prog);
  const u_mvp = gl.getUniformLocation(prog, 'u_mvp');
  gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);

  const g = createTexturedCubeGeometry();
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
  const vboPos = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.bufferData(gl.ARRAY_BUFFER, g.positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

  const vboUV = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboUV);
  gl.bufferData(gl.ARRAY_BUFFER, g.uvs, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);

  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, g.indices, gl.STATIC_DRAW);

  handles.create(vboPos);
  handles.create(vboUV);
  handles.create(ibo);

  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);

  const frame = (tSec = 0) => {
    const { w, h } = fitCanvasToDisplaySize(canvas);
    resizeWebGL2(canvas, gl, w, h);
    const proj  = perspective(Math.PI / 3, w / Math.max(1, h), 0.1, 100);
    const view  = orbit.getViewMatrix();
    const model = Mat4.rotationY((tSec * 0.001) % (2 * Math.PI));
    const mvp   = new Mat4(proj.m).multiply(view).multiply(model);

    gl.viewport(0, 0, w, h);
    gl.clearColor(0.07, 0.07, 0.09, 1.0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(prog);
    gl.uniformMatrix4fv(u_mvp, false, new Float32Array(mvp.m));

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, handles.get(textureHandle));
    gl.bindVertexArray(vao);
    gl.drawElements(gl.TRIANGLES, g.indices.length, gl.UNSIGNED_SHORT, 0);

    if (!frame._checked) {
      frame._checked = true;
      t.ok(w > 0 && h > 0, 'canvas sized');
      t.ok(handles.liveCount() > 0, 'resource handles protecting against leaks');
      t.ok(true, 'M2 DoD complete: textured cube + mipmaps + orbit camera + leak protection (WebGL2)');
    }
  };

  onResize(() => frame(performance.now()));
  rafLoop(frame);
}

await startWebGL2();
</script>
