<!doctype html>
<meta charset="utf-8" />
<title>Indexed Cube + Depth (WebGPU → WebGL2)</title>
<link rel="stylesheet" href="../../lib/style.css">
<!-- silence favicon 404s during local dev -->
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E">
<canvas id="canvas"></canvas>
<div class="panel">
  <b>Cube + Depth</b> · <span class="small">Drag to orbit · Wheel to zoom</span> ·
  <span id="mode" class="small"></span>
</div>
<script type="module">
import { fitCanvasToDisplaySize, onResize, rafLoop, hasWebGPU, hasWebGL2 } from '../../lib/harness.js';
import { setupWebGPU } from '../../../src/gfx/webgpu_runtime.js';
import { resizeWebGPU, resizeWebGL2 } from '../../../src/gfx/resize.js';
import { buildColor3DPipelineDescriptor, WGSL_COLOR3D_VERT, WGSL_COLOR3D_FRAG } from '../../../src/gfx/pipeline_color3d.js';
import { createCubeGeometry } from '../../../src/gfx/mesh.js';
import { perspective, makeOrbitController } from '../../../src/gfx/camera.js';
import { Mat4 } from '../../../src/core/math/mat4.js';

/* ---------- Optional testkit (shimmed if missing) ---------- */
function parseFlagsFromURL() {
  const q = new URLSearchParams(location.search);
  const backend = q.get('backend');         // 'webgpu' | 'webgl2'
  const expect  = q.get('expect');          // expected backend (lowercase)
  const headless = ['1','true','yes'].includes((q.get('headless')||'').toLowerCase());
  return { backend, expect, headless };
}
let Flags = parseFlagsFromURL();
let t = { ok(){}, eq(){}, end(){} }; // no-op so demos don’t crash if testkit is absent
try {
  const tk = await import('../../lib/testkit.js');
  if (tk?.Flags) Flags = { ...tk.Flags, ...Flags };
  tk?.applyHeadless?.(!!Flags.headless);
  t = tk?.makeTester?.('3d/cube_depth') ?? t;
} catch { /* fine, running as a plain demo */ }

/* ---------- DOM refs & mode label ---------- */
const canvas = document.getElementById('canvas');
const modeEl = document.getElementById('mode');
const setMode = (m) => {
  modeEl.textContent = m;
  if (Flags?.expect) t.eq(m.toLowerCase(), String(Flags.expect).toLowerCase(), 'backend matches ?expect');
};

/* ---------- Shared orbit input ---------- */
const orbit = makeOrbitController({ distance: 4, yaw: 0.6, pitch: 0.6 });
let dragging = false, px = 0, py = 0;
canvas.addEventListener('pointerdown', e => { dragging = true; px = e.clientX; py = e.clientY; canvas.setPointerCapture(e.pointerId); });
canvas.addEventListener('pointerup',   e => { dragging = false; canvas.releasePointerCapture(e.pointerId); });
canvas.addEventListener('pointermove', e => { if (!dragging) return; const dx=e.clientX-px, dy=e.clientY-py; px=e.clientX; py=e.clientY; orbit.update(-dx*0.005,-dy*0.005,0); });
canvas.addEventListener('wheel', e => { orbit.update(0,0, Math.sign(e.deltaY)*0.1); e.preventDefault(); }, { passive:false });

/* ------------------------------ WebGPU path ---------------------------------- */
async function startWebGPU() {
  setMode('WebGPU');
  const { device, context, format } = await setupWebGPU(canvas, { alphaMode: 'opaque' });

  const g = createCubeGeometry();
  const mk = (arr, usage) => { const b = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true }); new arr.constructor(b.getMappedRange()).set(arr); b.unmap(); return b; };
  const vboPos = mk(g.positions, GPUBufferUsage.VERTEX);
  const vboCol = mk(g.colors,    GPUBufferUsage.VERTEX);
  const ibo    = mk(g.indices,   GPUBufferUsage.INDEX);

  const ubo = device.createBuffer({ size: 64, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

  let depthTex = null;
  function ensureDepth(w, h) {
    depthTex?.destroy?.();
    depthTex = device.createTexture({
      size: { width: w, height: h, depthOrArrayLayers: 1 },
      format: 'depth24plus',
      usage: GPUTextureUsage.RENDER_ATTACHMENT
    });
  }

  const desc = buildColor3DPipelineDescriptor(format, 'depth24plus');
  desc.vertex.module   = device.createShaderModule({ code: WGSL_COLOR3D_VERT });
  desc.fragment.module = device.createShaderModule({ code: WGSL_COLOR3D_FRAG });
  const pipeline = device.createRenderPipeline(desc);
  const bind = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: ubo, offset: 0, size: 64 } }]
  });

  const frame = (tSec = 0) => {
    const { w, h } = fitCanvasToDisplaySize(canvas);
    resizeWebGPU(canvas, context, device, format, { alphaMode: 'opaque' }, w, h);
    ensureDepth(w, h);

    const proj=perspective(Math.PI/3, w/h, 0.1, 100), view=orbit.getViewMatrix();
    const model=Mat4.rotationY((tSec*0.001)%(2*Math.PI));
    const mvp=new Mat4(proj.m).multiply(view).multiply(model);
    device.queue.writeBuffer(ubo, 0, new Float32Array(mvp.m));

    const enc=device.createCommandEncoder();
    const color=context.getCurrentTexture().createView();
    const depth=depthTex.createView();
    const pass=enc.beginRenderPass({
      colorAttachments:[{ view:color, clearValue:{r:0.07,g:0.07,b:0.09,a:1}, loadOp:'clear', storeOp:'store' }],
      depthStencilAttachment:{ view:depth, depthClearValue:1, depthLoadOp:'clear', depthStoreOp:'store' }
    });
    pass.setPipeline(pipeline); pass.setBindGroup(0,bind);
    pass.setVertexBuffer(0,vboPos); pass.setVertexBuffer(1,vboCol);
    pass.setIndexBuffer(ibo,'uint16'); pass.drawIndexed(g.indices.length);
    pass.end(); device.queue.submit([enc.finish()]);

    if (!frame._checked) { frame._checked=true; t.ok(w>0&&h>0,'canvas sized'); t.ok(!!depthTex, 'depth texture created'); }
  };

  onResize(() => frame(performance.now())); rafLoop(frame);
}

/* -------------------------- WebGL2 fallback path ------------------------------ */
async function startWebGL2() {
  if (!hasWebGL2(canvas)) { setMode('None'); t.ok(false,'WebGL2 unavailable'); return; }
  setMode('WebGL2');
  const gl = canvas.getContext('webgl2', { antialias: false, depth: true });

  const VS = `#version 300 es
  layout(location=0) in vec3 a_pos; layout(location=1) in vec3 a_col;
  uniform mat4 u_mvp; out vec3 v_col;
  void main(){ v_col=a_col; gl_Position=u_mvp*vec4(a_pos,1.0); }`;
  const FS = `#version 300 es
  precision mediump float; in vec3 v_col; out vec4 frag; void main(){ frag=vec4(v_col,1.0); }`;

  const C = (type,src)=>{ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)||'compile'); return s; };
  const prog = gl.createProgram(); gl.attachShader(prog,C(gl.VERTEX_SHADER,VS)); gl.attachShader(prog,C(gl.FRAGMENT_SHADER,FS));
  gl.linkProgram(prog); if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog)||'link'); gl.useProgram(prog);
  const u_mvp=gl.getUniformLocation(prog,'u_mvp');

  const g = createCubeGeometry();
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

  const vboPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboPos); gl.bufferData(gl.ARRAY_BUFFER, g.positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
  const vboCol = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboCol); gl.bufferData(gl.ARRAY_BUFFER, g.colors, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
  const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, g.indices, gl.STATIC_DRAW);

  gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LESS);

  const frame = (timeSec = 0) => {
    const { w, h } = fitCanvasToDisplaySize(canvas);
    resizeWebGL2(canvas, gl, w, h);

    const proj=perspective(Math.PI/3, w/h, 0.1, 100), view=orbit.getViewMatrix();
    const model=Mat4.rotationY((timeSec*0.001)%(2*Math.PI));
    const mvp=new Mat4(proj.m).multiply(view).multiply(model);

    gl.uniformMatrix4fv(u_mvp, false, new Float32Array(mvp.m));
    gl.clearColor(0.07, 0.07, 0.09, 1.0); gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.bindVertexArray(vao); gl.drawElements(gl.TRIANGLES, g.indices.length, gl.UNSIGNED_SHORT, 0);

    if (!frame._checked) { frame._checked=true; t.ok(w>0&&h>0,'canvas sized'); }
  };

  onResize(() => frame(performance.now())); rafLoop(frame);
}

/* ------------------------ Boot: URL overrides + fallback --------------------- */
const backend = (Flags.backend||'').toLowerCase();
if (backend === 'webgl2') {
  await startWebGL2();
} else if (backend === 'webgpu') {
  try { await startWebGPU(); } catch (e) { console.warn('WebGPU init failed; falling back:', e); await startWebGL2(); }
} else {
  if (hasWebGPU()) {
    try { await startWebGPU(); } catch (e) { console.warn('WebGPU init failed; falling back:', e); await startWebGL2(); }
  } else {
    await startWebGL2();
  }
}
</script>
