<!doctype html>
<meta charset="utf-8" />
<title>Instanced Cubes (WebGPU/WebGL2)</title>
<link rel="stylesheet" href="../../lib/style.css">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E">
<canvas id="canvas"></canvas>
<div class="panel">
  <b>Instanced Cubes</b> 路
  <span class="small">Drag to orbit 路 Wheel to zoom</span> 路
  <span id="mode" class="small"></span> 路
  <span class="small">Count</span>
  <input id="count" type="range" min="32" max="2048" step="1" value="512">
  <span id="countv" class="small">512</span>
</div>

<script type="module">
import { fitCanvasToDisplaySize, onResize, rafLoop, hasWebGPU, hasWebGL2 } from '../../lib/harness.js';
import { setupWebGPU } from '../../../src/gfx/webgpu_runtime.js';
import { resizeWebGPU, resizeWebGL2 } from '../../../src/gfx/resize.js';
import { createCubeGeometry } from '../../../src/gfx/mesh.js';
import { perspective, makeOrbitController } from '../../../src/gfx/camera.js';
import { Mat4 } from '../../../src/core/math/mat4.js';
import { Flags, makeTester, applyHeadless, makeRng } from '../../lib/testkit.js';

applyHeadless(Flags.headless);
const T = makeTester('3d/instanced_cubes');

const canvas = document.getElementById('canvas');
const modeEl = document.getElementById('mode');
const countEl = document.getElementById('count');
const countV  = document.getElementById('countv');
countV.textContent = countEl.value;

const setMode = (m)=>{ modeEl.textContent=m; if (Flags.expect) T.eq(m.toLowerCase(), Flags.expect, 'backend matches ?expect'); };

// -------- Orbit interaction (shared) --------
const orbit = makeOrbitController({ distance: 6, yaw: 0.8, pitch: 0.7 });
let dragging = false, px = 0, py = 0;
canvas.addEventListener('pointerdown', e => { dragging = true; px = e.clientX; py = e.clientY; canvas.setPointerCapture(e.pointerId); });
canvas.addEventListener('pointerup',   e => { dragging = false; canvas.releasePointerCapture(e.pointerId); });
canvas.addEventListener('pointermove', e => { if (!dragging) return; const dx=e.clientX-px, dy=e.clientY-py; px=e.clientX; py=e.clientY; orbit.update(-dx*0.005,-dy*0.005,0); });
canvas.addEventListener('wheel', e => { orbit.update(0,0, Math.sign(e.deltaY)*0.15); e.preventDefault(); }, { passive:false });

// ===================================================================================
//                                       WebGPU
// ===================================================================================
async function startWebGPU() {
  setMode('WebGPU');
  const { device, context, format } = await setupWebGPU(canvas, { alphaMode: 'opaque' });

  const g = createCubeGeometry(); // positions(Float32), colors(Float32), indices(Uint16)
  const mk = (arr, usage) => {
    const b = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
    new arr.constructor(b.getMappedRange()).set(arr); b.unmap(); return b;
  };
  const vboPos = mk(g.positions, GPUBufferUsage.VERTEX);
  const vboCol = mk(g.colors,    GPUBufferUsage.VERTEX);
  const ibo    = mk(g.indices,   GPUBufferUsage.INDEX);

  // Instance data: [ px, py, pz, cr, cg, cb ] * N
  const MAX = 2048;
  const inst = new Float32Array(MAX * 6);
  const instBuf = device.createBuffer({ size: inst.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });

  const rng = makeRng(Flags.seed ?? 1337);
  function seed(n) {
    const cols = Math.ceil(Math.sqrt(n));
    const rows = Math.ceil(n / cols);
    let k = 0;
    for (let j = 0; j < rows; j++) for (let i = 0; i < cols && k < n; i++, k++) {
      const x = (i - (cols-1)/2) * 0.8 + (rng()-0.5)*0.05;
      const y = (j - (rows-1)/2) * 0.8 + (rng()-0.5)*0.05;
      const z = (rng()-0.5) * 0.8;
      const cr = 0.4 + 0.6 * rng();
      const cg = 0.4 + 0.6 * rng();
      const cb = 0.4 + 0.6 * rng();
      inst[k*6+0]=x; inst[k*6+1]=y; inst[k*6+2]=z;
      inst[k*6+3]=cr; inst[k*6+4]=cg; inst[k*6+5]=cb;
    }
    device.queue.writeBuffer(instBuf, 0, inst, 0, n * 6);
  }

  // Uniforms: vp matrix (mat4x4), time (f32) + padding
  const UBO_SIZE = 64 + 16; // mat4 + vec4
  const ubo = device.createBuffer({ size: UBO_SIZE, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  const writeUniforms = (vp, t) => {
    const buf = new Float32Array(20);
    buf.set(vp.m, 0); // 16
    buf[16] = t;      // rest padding
    device.queue.writeBuffer(ubo, 0, buf.buffer);
  };

  // Depth
  let depthTex = null;
  function ensureDepth(w, h) {
    depthTex?.destroy?.();
    depthTex = device.createTexture({ size:{width:w,height:h,depthOrArrayLayers:1}, format:'depth24plus', usage:GPUTextureUsage.RENDER_ATTACHMENT });
  }

  // Shaders
  const VS = /* wgsl */`
  struct U { vp: mat4x4<f32>, time: vec4<f32> };
  @group(0) @binding(0) var<uniform> u: U;

  struct VSIn {
    @location(0) p: vec3<f32>,
    @location(1) col: vec3<f32>,
    @location(2) ipos: vec3<f32>,
    @location(3) icol: vec3<f32>,
  };
  struct VSOut {
    @builtin(position) clip: vec4<f32>,
    @location(0) vcol: vec3<f32>,
  };

  @vertex fn main(in: VSIn) -> VSOut {
    let angle = u.time.x + in.ipos.x * 0.7 + in.ipos.y * 0.9;
    let c = cos(angle); let s = sin(angle);
    let R = mat3x3<f32>(
      vec3<f32>( c, 0.0, s),
      vec3<f32>(0.0, 1.0, 0.0),
      vec3<f32>(-s, 0.0, c)
    );
    let world = (R * in.p) + in.ipos;
    var o: VSOut;
    o.clip = u.vp * vec4<f32>(world, 1.0);
    o.vcol = (in.col * 0.5) + (in.icol * 0.5);
    return o;
  }`;

  const FS = /* wgsl */`
  @fragment fn main(@location(0) vcol: vec3<f32>) -> @location(0) vec4<f32> {
    return vec4<f32>(vcol, 1.0);
  }`;

  const pipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: { module: device.createShaderModule({ code: VS }), entryPoint:'main',
      buffers: [
        { arrayStride: 12, attributes:[{ shaderLocation:0, offset:0, format:'float32x3' }] }, // positions
        { arrayStride: 12, attributes:[{ shaderLocation:1, offset:0, format:'float32x3' }] }, // colors
        { arrayStride: 24, stepMode:'instance', attributes:[ // instances: pos + col
          { shaderLocation:2, offset: 0, format:'float32x3' },
          { shaderLocation:3, offset:12, format:'float32x3' },
        ]},
      ]},
    fragment: { module: device.createShaderModule({ code: FS }), entryPoint:'main',
      targets: [{ format }] },
    primitive: { topology:'triangle-list', cullMode:'back' },
    depthStencil: { format:'depth24plus', depthWriteEnabled:true, depthCompare:'less' },
  });

  const bind = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding:0, resource:{ buffer:ubo, offset:0, size:UBO_SIZE } }]
  });

  function frame(t=0) {
    const { w, h } = fitCanvasToDisplaySize(canvas);
    resizeWebGPU(canvas, context, device, format, { alphaMode:'opaque' }, w, h);
    ensureDepth(w, h);

    const proj=perspective(Math.PI/3, w/h, 0.1, 100), view=orbit.getViewMatrix();
    const vp  = new Mat4(proj.m).multiply(view);
    writeUniforms(vp, t*0.001);

    const enc  = device.createCommandEncoder();
    const viewTex = context.getCurrentTexture().createView();
    const pass = enc.beginRenderPass({
      colorAttachments: [{ view: viewTex, clearValue:{ r:.07,g:.07,b:.10,a:1 }, loadOp:'clear', storeOp:'store' }],
      depthStencilAttachment: { view: depthTex.createView(), depthClearValue:1, depthLoadOp:'clear', depthStoreOp:'store' }
    });

    const n = parseInt(countEl.value, 10);
    pass.setPipeline(pipeline); pass.setBindGroup(0, bind);
    pass.setVertexBuffer(0, vboPos); pass.setVertexBuffer(1, vboCol); pass.setVertexBuffer(2, instBuf);
    pass.setIndexBuffer(ibo, 'uint16'); pass.drawIndexed(g.indices.length, n);
    pass.end(); device.queue.submit([enc.finish()]);

    countV.textContent = String(n);
    if (!frame._once){ frame._once=true; T.ok(w>0&&h>0,'canvas sized'); }
  }

  seed(parseInt(countEl.value, 10));
  onResize(()=>frame(performance.now()));
  rafLoop(frame);
  countEl.addEventListener('input', ()=>frame(performance.now()));
}

// ===================================================================================
//                                       WebGL2
// ===================================================================================
function startWebGL2() {
  if (!hasWebGL2(canvas)) { setMode('None'); T.ok(false,'WebGL2 unavailable'); return; }
  setMode('WebGL2');
  const gl = canvas.getContext('webgl2', { antialias:false, depth:true });

  const VS = `#version 300 es
  layout(location=0) in vec3 a_pos;
  layout(location=1) in vec3 a_col;
  layout(location=2) in vec3 i_pos;
  layout(location=3) in vec3 i_col;

  uniform mat4 u_vp;
  uniform float u_time;

  out vec3 v_col;

  void main(){
    float a = u_time + i_pos.x * 0.7 + i_pos.y * 0.9;
    float c = cos(a), s = sin(a);
    mat3 R = mat3(
      c, 0.0, s,
      0.0, 1.0, 0.0,
     -s, 0.0, c
    );
    vec3 world = R * a_pos + i_pos;
    gl_Position = u_vp * vec4(world, 1.0);
    v_col = (a_col * 0.5) + (i_col * 0.5);
  }`;

  const FS = `#version 300 es
  precision mediump float;
  in vec3 v_col;
  out vec4 frag;
  void main(){ frag = vec4(v_col, 1.0); }`;

  const C=(t,s)=>{ const sh=gl.createShader(t); gl.shaderSource(sh,s); gl.compileShader(sh);
    if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh)||'compile'); return sh; };
  const prog = gl.createProgram();
  gl.attachShader(prog, C(gl.VERTEX_SHADER,VS));
  gl.attachShader(prog, C(gl.FRAGMENT_SHADER,FS));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog)||'link');
  gl.useProgram(prog);

  const u_vp   = gl.getUniformLocation(prog, 'u_vp');
  const u_time = gl.getUniformLocation(prog, 'u_time');

  const g = createCubeGeometry();
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

  // Per-vertex
  const vboPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.bufferData(gl.ARRAY_BUFFER, g.positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

  const vboCol = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
  gl.bufferData(gl.ARRAY_BUFFER, g.colors, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

  const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, g.indices, gl.STATIC_DRAW);

  // Per-instance: [px,py,pz, cr,cg,cb]
  const MAX = 2048;
  const STRIDE = 24; // 6 * 4 bytes
  const inst = new Float32Array(MAX * 6);
  const instBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
  gl.bufferData(gl.ARRAY_BUFFER, inst.byteLength, gl.DYNAMIC_DRAW);

  // i_pos
  gl.enableVertexAttribArray(2); gl.vertexAttribPointer(2, 3, gl.FLOAT, false, STRIDE, 0);
  gl.vertexAttribDivisor(2, 1);
  // i_col
  gl.enableVertexAttribArray(3); gl.vertexAttribPointer(3, 3, gl.FLOAT, false, STRIDE, 12);
  gl.vertexAttribDivisor(3, 1);

  const rng = makeRng(Flags.seed ?? 1337);
  function seed(n) {
    const cols = Math.ceil(Math.sqrt(n));
    const rows = Math.ceil(n / cols);
    let k = 0;
    for (let j = 0; j < rows; j++) for (let i = 0; i < cols && k < n; i++, k++) {
      const x = (i - (cols-1)/2) * 0.8 + (rng()-0.5)*0.05;
      const y = (j - (rows-1)/2) * 0.8 + (rng()-0.5)*0.05;
      const z = (rng()-0.5) * 0.8;
      const cr = 0.4 + 0.6 * rng();
      const cg = 0.4 + 0.6 * rng();
      const cb = 0.4 + 0.6 * rng();
      inst[k*6+0]=x; inst[k*6+1]=y; inst[k*6+2]=z;
      inst[k*6+3]=cr; inst[k*6+4]=cg; inst[k*6+5]=cb;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, instBuf);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, inst.subarray(0, n * 6));
  }

  gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LESS); gl.enable(gl.CULL_FACE); gl.cullFace(gl.BACK);

  function frame(t=0) {
    const { w, h } = fitCanvasToDisplaySize(canvas);
    resizeWebGL2(canvas, gl, w, h);

    const proj=perspective(Math.PI/3, w/h, 0.1, 100), view=orbit.getViewMatrix();
    const vp  = new Mat4(proj.m).multiply(view);
    gl.uniformMatrix4fv(u_vp, false, new Float32Array(vp.m));
    gl.uniform1f(u_time, t * 0.001);

    gl.viewport(0,0,w,h);
    gl.clearColor(0.07,0.07,0.10,1); gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const n = parseInt(countEl.value, 10);
    gl.bindVertexArray(vao);
    gl.drawElementsInstanced(gl.TRIANGLES, g.indices.length, gl.UNSIGNED_SHORT, 0, n);

    countV.textContent = String(n);
    if (!frame._once){ frame._once=true; T.ok(w>0&&h>0,'canvas sized'); }
  }

  seed(parseInt(countEl.value, 10));
  onResize(()=>frame(performance.now()));
  rafLoop(frame);
  countEl.addEventListener('input', ()=>frame(performance.now()));
}

// ------------------------ Boot & fallback ------------------------
if (Flags.backend === 'webgl2') {
  startWebGL2();
} else if (Flags.backend === 'webgpu') {
  try { await startWebGPU(); } catch (e) { console.warn('Forced WebGPU failed; fallback:', e); startWebGL2(); }
} else {
  if (hasWebGPU()) { try { await startWebGPU(); } catch (e) { console.warn('WebGPU init failed; fallback:', e); startWebGL2(); } }
  else startWebGL2();
}
</script>
